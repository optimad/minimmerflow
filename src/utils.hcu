/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_UTILS_HCU__
#define __MINIMMERFLOW_UTILS_HCU__

#include "containers.hcu"
#include "containers.cu"
#include "constants.hcu"

namespace utils {

/*!
 * Calculates normal velocity from primitive variables.
 *
 * \param u is the x-component of the velocity vector
 * \param v is the y-component of the velocity vector
 * \param w is the z-component of the velocity vector
 * \param nx is the x-component of the normal vector
 * \param ny is the y-component of the normal vector
 * \param nz is the z-component of the normal vector
 * \result The normal velocity.
 */
__device__ __forceinline__ double dev_normalVelocity(double u, double v, double w, double nx, double ny, double nz)
{
    return (u * nx + v * ny + w * nz);
};

/*!
 * Compute primitive variables from conservative variables for a ideal gas.
 *
 * \param c are the conservative variables
 * \param[out] p are the primitive variables
 */
template<int BLOCK_SIZE>
__device__ __forceinline__ void dev_conservative2primitive(const DeviceSharedArray<double, BLOCK_SIZE> & __restrict__ c,
                                                           DeviceProxyArray<double, BLOCK_SIZE> * __restrict__ p)
{
    // Density
    double rho = c[DEV_FID_RHO];

    double rho_inv = 1. / rho;

    // Velocity
    double3 u = make_double3(c[DEV_FID_U] * rho_inv, c[DEV_FID_V] * rho_inv, c[DEV_FID_W] * rho_inv);

    (*p)[DEV_FID_U] = u.x;
    (*p)[DEV_FID_V] = u.y;
    (*p)[DEV_FID_W] = u.z;

    // Temperature
    double K = 0.5 * (u.x * u.x + u.y * u.y + u.z * u.z);
    double e = c[DEV_FID_RHO_E] * rho_inv;
    double T = (e - K) * (DEV_GAMMA - 1.0);

    (*p)[DEV_FID_T] = T;

    // Pressure
    (*p)[DEV_FID_P] = rho * T;
};

/*!
 * Compute conservative variables from primitive variables for a ideal gas.
 *
 * \param p are the primitive variables
 * \param[out] c are the conservative variables
 */
template<int BLOCK_SIZE>
__device__ __forceinline__ void dev_primitive2conservative(const DeviceProxyArray<double, BLOCK_SIZE> & __restrict__ p,
                                                           DeviceProxyArray<double, BLOCK_SIZE> * __restrict__ c)
{
    // Continuity
    double T   = p[DEV_FID_T];
    double rho = p[DEV_FID_P] / T;

    (*c)[DEV_FID_RHO] = rho;

    // Momentum
    double3 u = make_double3(p[DEV_FID_U], p[DEV_FID_V], p[DEV_FID_W]);

    (*c)[DEV_FID_RHO_U] = rho * u.x;
    (*c)[DEV_FID_RHO_V] = rho * u.y;
    (*c)[DEV_FID_RHO_W] = rho * u.z;

    // Total energy
    double K = 0.5 * (u.x * u.x + u.y * u.y + u.z * u.z);

    (*c)[DEV_FID_RHO_E] = rho * (T / (DEV_GAMMA - 1.0) + K);
};

}

#endif

