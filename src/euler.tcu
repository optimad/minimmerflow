/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_EULER_TCU__
#define __MINIMMERFLOW_EULER_TCU__

namespace euler {

/*!
 * Sum the conservative fluxes for a perfect gas.
 *
 * \param conservative is the conservative state
 * \param n is the normal direction
 * \param[out] coefficient is the coefficient that will be used when summing
 * the fluxes
 * \param[in,out] fluxes are the conservative fluxes, on output it will be
 * updated summing the fluxes of the specified state multiplied by the given
 * coefficient
 * \param[in,out] lambda is the maximum eigenvalue, on output it will be
 * updated using the eigenvalue of the specified state
 */
template<int BLOCK_SIZE>
__device__ void dev_sumFluxes(const DeviceSharedArray<double, BLOCK_SIZE> &conservative, const double3 &normal,
                              double coefficient, DeviceSharedArray<double, BLOCK_SIZE> *fluxes, double *lambda)
{
    // Compute primitive variables
    //
    // To reduce the usage of shared memory, primitive fields are evaluated on
    // the storage that will hold the fluxes.
    double primitive[N_FIELDS];

    ::utils::dev_conservative2primitive(conservative, primitive);

    // Validate state
    if (primitive[FID_P] < 0.) {
        printf("***** Negative pressure (%f) in flux computation!\n", primitive[FID_P]);
    }

    if (conservative[FID_RHO] < 0.) {
       printf("***** Negative density (%f) in flux computation!\n", conservative[FID_RHO]);
    }

    // Speed of sound
    double a = std::sqrt(GAMMA * primitive[FID_T]);

    // Velocity
    double3 u = make_double3(primitive[FID_U], primitive[FID_V], primitive[FID_W]);
    double un = ::utils::dev_normalVelocity(u.x, u.y, u.z, normal.x, normal.y, normal.z);

    // Update maximum eigenvalue
    *lambda = max(std::abs(un) + a, *lambda);

    // Mass flux
    double massFlux = conservative[FID_RHO] * un;

    // Continuity flux
    (*fluxes)[FID_EQ_C] += coefficient * massFlux;

    // Momentum flux
    (*fluxes)[FID_EQ_M_X] += coefficient * (massFlux * u.x + primitive[FID_P] * normal.x);
    (*fluxes)[FID_EQ_M_Y] += coefficient * (massFlux * u.y + primitive[FID_P] * normal.y);
    (*fluxes)[FID_EQ_M_Z] += coefficient * (massFlux * u.z + primitive[FID_P] * normal.z);

    // Energy flux
    double rho_K = 0.5 * conservative[FID_RHO] * (u.x * u.x + u.y * u.y + u.z * u.z);
    double eto   = primitive[FID_P] / (GAMMA - 1.) + rho_K;

    (*fluxes)[FID_EQ_E] += coefficient * un * (eto + primitive[FID_P]);
}

/*!
 * Solve the given Riemann problem using the Local Lax Friedrichs approximate
 * solver.
 *
 * \param conservativeL is the left conservative state
 * \param conservativeR is the right conservative state
 * \param n is the normal
 * \param[out] fluxes on output will contain the conservative fluxes
 * \param[out] lambda on output will contain the maximum eigenvalue
 */
template<int BLOCK_SIZE>
__device__ void dev_solveRiemann(const DeviceSharedArray<double, BLOCK_SIZE> &conservativeL, const DeviceSharedArray<double, BLOCK_SIZE> &conservativeR,
                                 const double3 &normal, DeviceSharedArray<double, BLOCK_SIZE> *fluxes, double *lambda)
{
    // Fluxes on the left side
    dev_sumFluxes(conservativeL, normal, 0.5, fluxes, lambda);

    // Fluxes on the right side
    dev_sumFluxes(conservativeR, normal, 0.5, fluxes, lambda);

    // Lax Friedrichs correction
    for (int k = 0; k < N_FIELDS; ++k) {
        (*fluxes)[k] -= 0.5 * (*lambda) * (conservativeR[k] - conservativeL[k]);
    }
}

/*!
 * Evaluate cell values on interface centroids.
 *
 * \param nInterfaces is the number of solved interfaces
 * \param interfaceRawIds are the raw ids of the solved interfaces
 * \param interfaceCentroids are the centroid of the interfaces
 * \param cellRawIds are the raw ids of the cells
 * \param cellValues are the cell values
 * \param order is the reconstruction order
 * \param[out] interfaceValues are the interface values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalInterfaceValues(int order, const double3 &point,
                                        const DeviceCollectionDataConstCursor<double> &means,
                                        DeviceSharedArray<double, BLOCK_SIZE> *values)
{
    reconstruction::dev_eval<BLOCK_SIZE>(order, point, means, values);
}

/*!
 * Computes the boundary values for the specified interface.
 *
 * \param problemType is the type of problem being solved
 * \param BCType is the type of boundary condition to apply
 * \param point is the point where the boundary condition should be applied
 * \param normal is the normal needed for evaluating the boundary condition
 * \param innerValues are the inner innerValues values
 * \param[out] boundaryValues are the boundary values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalInterfaceBCValues(int problemType, int BCType, const double3 &point, const double3 &normal,
                                          const DeviceSharedArray<double, BLOCK_SIZE> &innerValues,
                                          DeviceSharedArray<double, BLOCK_SIZE> *boundaryValues)
{
    double info[BC_INFO_SIZE];
    problem::dev_getBorderBCInfo(problemType, BCType, point, normal, info);

    switch (BCType)
    {
        case BC_FREE_FLOW:
            dev_evalFreeFlowBCValues<BLOCK_SIZE>(point, normal, info, innerValues, boundaryValues);
            break;

        case BC_REFLECTING:
            dev_evalReflectingBCValues<BLOCK_SIZE>(point, normal, info, innerValues, boundaryValues);
            break;

        case BC_WALL:
            dev_evalWallBCValues<BLOCK_SIZE>(point, normal, info, innerValues, boundaryValues);
            break;

        case BC_DIRICHLET:
            dev_evalDirichletBCValues<BLOCK_SIZE>(point, normal, info, innerValues, boundaryValues);
            break;

    }
}

/*!
 * Computes the boundary values for the free flow BC.
 *
 * \param point is the point where the boundary condition should be applied
 * \param normal is the normal needed for evaluating the boundary condition
 * \param info are the info needed for evaluating the boundary condition
 * \param innerValues are the inner innerValues values
 * \param[out] boundaryValues are the boundary values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalFreeFlowBCValues(const double3 &point, const double3 &normal, double *info,
                                         const DeviceSharedArray<double, BLOCK_SIZE> &innerValues,
                                         DeviceSharedArray<double, BLOCK_SIZE> *boundaryValues)
{
    BITPIT_UNUSED(point);
    BITPIT_UNUSED(normal);
    BITPIT_UNUSED(info);

    for (int i = 0; i < N_FIELDS; ++i) {
        (*boundaryValues)[i] = innerValues[i];
    }
}

/*!
 * Computes the boundary values for the reflecting BC.
 *
 * \param point is the point where the boundary condition should be applied
 * \param normal is the normal needed for evaluating the boundary condition
 * \param info are the info needed for evaluating the boundary condition
 * \param innerValues are the inner innerValues values
 * \param[out] boundaryValues are the boundary values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalReflectingBCValues(const double3 &point, const double3 &normal, double *info,
                                           const DeviceSharedArray<double, BLOCK_SIZE> &innerValues,
                                           DeviceSharedArray<double, BLOCK_SIZE> *boundaryValues)
{
    BITPIT_UNUSED(point);
    BITPIT_UNUSED(info);

    // Evaluate primitive variables
    double primitive[N_FIELDS];
    ::utils::dev_conservative2primitive(innerValues, primitive);

    // Apply boundary condition
    double3 u = make_double3(primitive[FID_U], primitive[FID_V], primitive[FID_W]);
    double un = ::utils::dev_normalVelocity(u.x, u.y, u.z, normal.x, normal.y, normal.z);

    primitive[FID_U] -= 2 * u.x * normal.x;
    primitive[FID_V] -= 2 * u.y * normal.y;
    primitive[FID_W] -= 2 * u.z * normal.z;

    // Evaluate conservative values
    ::utils::dev_primitive2conservative(primitive, boundaryValues);
}

/*!
 * Computes the boundary values for the wall BC.
 *
 * \param point is the point where the boundary condition should be applied
 * \param normal is the normal needed for evaluating the boundary condition
 * \param info are the info needed for evaluating the boundary condition
 * \param innerValues are the inner innerValues values
 * \param[out] boundaryValues are the boundary values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalWallBCValues(const double3 &point, const double3 &normal, double *info,
                                     const DeviceSharedArray<double, BLOCK_SIZE> &innerValues,
                                     DeviceSharedArray<double, BLOCK_SIZE> *boundaryValues)
{
    BITPIT_UNUSED(point);
    BITPIT_UNUSED(info);

    dev_evalReflectingBCValues(point, normal, info, innerValues, boundaryValues);
}

/*!
 * Computes the boundary values for the dirichlet BC.
 *
 * \param point is the point where the boundary condition should be applied
 * \param normal is the normal needed for evaluating the boundary condition
 * \param info are the info needed for evaluating the boundary condition
 * \param innerValues are the inner innerValues values
 * \param[out] boundaryValues are the boundary values
 */
template<int BLOCK_SIZE>
__device__ void dev_evalDirichletBCValues(const double3 &point, const double3 &normal, double *info,
                                          const DeviceSharedArray<double, BLOCK_SIZE> &innerValues,
                                          DeviceSharedArray<double, BLOCK_SIZE> *boundaryValues)
{
    BITPIT_UNUSED(point);
    BITPIT_UNUSED(normal);
    BITPIT_UNUSED(innerValues);

    ::utils::dev_primitive2conservative(info, boundaryValues);
}

/*!
 * Update residual of cells associated with uniform interfaces.
 *
 * \param nInterfaces is the number of solved interfaces
 * \param reconstructionOrder is the order at wich values will be reconstructed
 * on the interfaces
 * \param interfaceRawIds are the raw ids of the solved interfaces
 * \param interfaceNormals are the normals of the interfaces
 * \param interfaceAreas are the areas of the interfaces
 * \param interfaceCentroids are the centroids of the interfaces
 * \param leftCellRawIds are the raw ids of the left cells
 * \param rightCellRawIds are the raw ids of the right cells
 * \param cellConvervatives are the conservative fileds on the cells
 * \param[out] cellRHS are the RHS of the cells
 * \param[out] maxEig on output will containt the maximum eigenvalue
 */
template<int BLOCK_SIZE>
__global__ void dev_uniformUpdateRHS(std::size_t nInterfaces, int reconstructionOrder,
                                     const std::size_t *interfaceRawIds, const double *interfaceAreas,
                                     const double * const *interfaceNormals, const double * const *interfaceCentroids,
                                     const std::size_t *leftCellRawIds, const std::size_t *rightCellRawIds,
                                     const double * const *cellConvervatives, double **cellRHS, double *maxEig)
{
    // Initialize shared storage
    //
    // The shared storage is logically divided in three slots, each of these
    // slots can contain a sets of conservative variables.
    extern __shared__ double sharedStorage[];

    const std::size_t sharedSlotSize = DeviceSharedArray<double, BLOCK_SIZE>::evaluateSharedSize(N_FIELDS);

    // Process interfaces
    for (int i = blockIdx.x * blockDim.x + threadIdx.x; i < nInterfaces; i += blockDim.x * gridDim.x) {
        // Get interface information
        const std::size_t interfaceRawId = interfaceRawIds[i];

        // Cell information
        const std::size_t leftCellRawId  = leftCellRawIds[i];
        const std::size_t rightCellRawId = rightCellRawIds[i];

        //
        // Reconstruct interface values
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: not used
        //    Slot #2: left side reconstructed variables
        //    Slot #3: right side reconstructed variables
        double3 interfaceCentroid = make_double3(interfaceCentroids[0][interfaceRawId], interfaceCentroids[1][interfaceRawId], interfaceCentroids[2][interfaceRawId]);

        DeviceCollectionDataConstCursor<double> cellConservativesCursor(cellConvervatives, 0);

        cellConservativesCursor.set(leftCellRawId);
        double *leftReconstructionsStorage = &(sharedStorage[sharedSlotSize]);
        DeviceSharedArray<double, BLOCK_SIZE> leftInterfaceConservatives(leftReconstructionsStorage);
        dev_evalInterfaceValues(reconstructionOrder, interfaceCentroid, cellConservativesCursor, &leftInterfaceConservatives);

        cellConservativesCursor.set(rightCellRawId);
        double *rightReconstructionsStorage = &(sharedStorage[2 * sharedSlotSize]);
        DeviceSharedArray<double, BLOCK_SIZE> rightInterfaceConservatives(rightReconstructionsStorage);
        dev_evalInterfaceValues(reconstructionOrder, interfaceCentroid, cellConservativesCursor, &rightInterfaceConservatives);

        //
        // Evaluate interface fluxes
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: interface fluxes
        //    Slot #2: left side reconstructed variables
        //    Slot #3: right side reconstructed variables
        double3 interfaceNormal = make_double3(interfaceNormals[0][interfaceRawId], interfaceNormals[1][interfaceRawId], interfaceNormals[2][interfaceRawId]);

        double *interfaceFluxesStorage = &(sharedStorage[0]);
        DeviceSharedArray<double, BLOCK_SIZE> interfaceFluxes(interfaceFluxesStorage);
        for (int k = 0; k < N_FIELDS; ++k) {
            interfaceFluxes[k] = 0.;
        }

        double interfaceMaxEig = 0.;

        dev_solveRiemann(leftInterfaceConservatives, rightInterfaceConservatives, interfaceNormal, &interfaceFluxes, &interfaceMaxEig);

        //
        // Update cell residuals
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: interface fluxes
        //    Slot #2: not used
        //    Slot #3: not used
        const double interfaceCoefficient = interfaceAreas[interfaceRawId];
        for (int k = 0; k < N_FIELDS; ++k) {
            double fieldContribution = interfaceCoefficient * interfaceFluxes[k];
            double *fieldRHS = cellRHS[k];

            atomicAdd(fieldRHS + leftCellRawId, - fieldContribution);
            atomicAdd(fieldRHS + rightCellRawId, fieldContribution);
        }

        // Update maximum eigenvalue
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: workspace for eigenvalue reduction
        //    Slot #2: not used
        //    Slot #3: not used
        double *reductionWorkspace = &(sharedStorage[0]);
        dev_reduceMax(interfaceMaxEig, nInterfaces, reductionWorkspace, maxEig);
    }
}

/*!
 * Update residual of cells associated with boundary interfaces.
 *
 * \param nInterfaces is the number of solved interfaces
 * \param interfaceRawIds are the raw ids of the solved interfaces
 * \param interfaceAreas are the areas of the interfaces
 * \param interfaceNormals are the normals of the interfaces
 * \param interfaceCentroids are the centroids of the interfaces
 * \param fluidCellRawIds are the raw ids of the fluid cells
 * \param cellConvervatives are the conservative fileds on the cells
 * \param boundarySigns are the signs of the boundaries
 * \param[out] cellRHS are the RHS of the cells
 * \param[out] maxEig on output will containt the maximum eigenvalue
 */
template<int BLOCK_SIZE>
__global__ void dev_boundaryUpdateRHS(std::size_t nInterfaces, int problemType, int reconstructionOrder,
                                      const std::size_t *interfaceRawIds, const double *interfaceAreas,
                                      const double * const *interfaceNormals, const double * const *interfaceCentroids,
                                      const std::size_t *fluidCellRawIds, const double * const *cellConvervatives,
                                      const int *boundarySigns, const int *boundaryBCs, double **cellRHS, double *maxEig)
{
    // Initialize shared storage
    //
    // The shared storage is logically divided in three slots, each of these
    // slots can contain a sets of conservative variables.
    extern __shared__ double sharedStorage[];

    const std::size_t sharedSlotSize = DeviceSharedArray<double, BLOCK_SIZE>::evaluateSharedSize(N_FIELDS);

    // Process interfaces
    for (int i = blockIdx.x * blockDim.x + threadIdx.x; i < nInterfaces; i += blockDim.x * gridDim.x) {
        // Get interface information
        const std::size_t interfaceRawId = interfaceRawIds[i];

        // Cell information
        const std::size_t fluidCellRawId = fluidCellRawIds[i];

        //
        // Reconstruct interface values
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: not used
        //    Slot #2: fluid side reconstructed variables
        //    Slot #3: virtual side reconstructed conservative variables
        double3 interfaceCentroid = make_double3(interfaceCentroids[0][interfaceRawId], interfaceCentroids[1][interfaceRawId], interfaceCentroids[2][interfaceRawId]);
        double3 interfaceNormal   = make_double3(interfaceNormals[0][interfaceRawId], interfaceNormals[1][interfaceRawId], interfaceNormals[2][interfaceRawId]);

        DeviceCollectionDataConstCursor<double> fluidCellConservativesCursor(cellConvervatives, fluidCellRawId);
        double *fluidReconstructionStorage = &(sharedStorage[sharedSlotSize]);
        DeviceSharedArray<double, BLOCK_SIZE> fluidInterfaceConservatives(fluidReconstructionStorage);
        dev_evalInterfaceValues(reconstructionOrder, interfaceCentroid, fluidCellConservativesCursor, &fluidInterfaceConservatives);

        const int interfaceBC = boundaryBCs[i];
        double *virtualReconstructionStorage = &(sharedStorage[2 * sharedSlotSize]);
        DeviceSharedArray<double, BLOCK_SIZE> virtualInterfaceConservatives(virtualReconstructionStorage);
        dev_evalInterfaceBCValues(problemType, interfaceBC, interfaceCentroid, interfaceNormal, fluidInterfaceConservatives, &virtualInterfaceConservatives);

        //
        // Evaluate interface fluxes
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: interface fluxes
        //    Slot #2: fluid side reconstructed variables
        //    Slot #3: virtual side reconstructed variables
        double *interfaceFluxesStorage = &(sharedStorage[0]);
        DeviceSharedArray<double, BLOCK_SIZE> interfaceFluxes(interfaceFluxesStorage);
        for (int k = 0; k < N_FIELDS; ++k) {
            interfaceFluxes[k] = 0.;
        }

        double interfaceMaxEig = 0.;

        dev_solveRiemann(fluidInterfaceConservatives, virtualInterfaceConservatives, interfaceNormal, &interfaceFluxes, &interfaceMaxEig);

        //
        // Update cell residuals
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: interface fluxes
        //    Slot #2: not used
        //    Slot #3: not used
        const int boundarySign     = boundarySigns[i];
        const double interfaceArea = interfaceAreas[interfaceRawId];

        const double interfaceCoefficient = boundarySign * interfaceArea;
        for (int k = 0; k < N_FIELDS; ++k) {
            double cellContribution = interfaceCoefficient * interfaceFluxes[k];

            atomicAdd(&(cellRHS[k][fluidCellRawId]), - cellContribution);
        }

        // Update maximum eigenvalue
        //
        // During this stage usage of shared memory is the following:
        //    Slot #1: workspace for eigenvalue reduction
        //    Slot #2: not used
        //    Slot #3: not used
        double *reductionWorkspace = &(sharedStorage[0]);
        dev_reduceMax(interfaceMaxEig, nInterfaces, reductionWorkspace, maxEig);
    }
}

}

#endif
