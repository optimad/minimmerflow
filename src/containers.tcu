/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_CONTAINERS_TCU__
#define __MINIMMERFLOW_CONTAINERS_TCU__

/*!
 * Allocate cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_allocate()
{
    cudaMalloc((void **) &m_devData, this->cuda_devSize() * sizeof(value_t));
}

/*!
 * Free cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_free()
{
    cudaFree(m_devData);
}

/*!
 * Update host data using device data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateHost()
{
    cudaMemcpy(this->data(), m_devData, this->cuda_devSize() * sizeof(value_t), cudaMemcpyDeviceToHost);
}

/*!
 * Update device data using host data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateDevice()
{
    cudaMemcpy(m_devData, this->data(), this->cuda_devSize() * sizeof(value_t), cudaMemcpyHostToDevice);
}

/*!
 * Gets a pointer to the device data storage.
 *
 * \result A pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_devData()
{
    return m_devData;
}

/*!
 * Gets a constant pointer to the device data storage.
 *
 * \result A constant pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
const dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_devData() const
{
    return m_devData;
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_devFill(const dev_value_t &value)
{
    cudaMemset(this->m_devData, value, this->cuda_devSize() * sizeof(value_t));
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValuePiercedStorage<value_t, dev_value_t>::cuda_devSize() const
{
    return (this->rawSize() * this->getFieldCount());
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_devSize() const
{
    return this->size();
}

#endif
