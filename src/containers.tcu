/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_CONTAINERS_TCU__
#define __MINIMMERFLOW_CONTAINERS_TCU__

namespace containers {

/*!
 * Set all storage elements to the specified value.
 *
 * \param count are the number of elements that will be set
 * \param data is a pointer to the first element
 * \param is the value that will be set
 */
template<typename dev_value_t>
__global__ void dev_setValue(std::size_t nElements, dev_value_t value, dev_value_t *data)
{
    unsigned int i = (blockIdx.x * blockDim.x) + threadIdx.x;
    for(; i < nElements; i += gridDim.x*blockDim.x) {
        data[i] = value;
    }
}

}

/*!
 * Allocate cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_allocateDevice()
{
    std::size_t deviceBytes = this->cuda_deviceDataSize() * sizeof(dev_value_t);

//  CUDA_ERROR_CHECK(cudaMalloc((void **) &m_dp, deviceBytes));
    this->cuda_resize(this->cuda_deviceDataSize());
}

/*!
 * Free cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_freeDevice()
{
#if ENABLE_OPENACC
    acc_unmap_data(this->data());
#endif
}

/*!
 * Resize memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_resize(size_t new_sz)
{
    std::size_t deviceBytes = new_sz * sizeof(dev_value_t);

#if ENABLE_OPENACC
    acc_unmap_data(this->data());
#endif

    (void)cuda_grow(deviceBytes);

#if ENABLE_OPENACC
//  acc_unmap_data(this->data());
//  acc_map_data(this->data(), (dev_value_t*)(m_dp), deviceBytes);
    acc_map_data(this->data(), this->cuda_deviceData(), deviceBytes);
#endif
}

/*!
 * Update host data using device data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateHost()
{
    CUDA_ERROR_CHECK(cudaMemcpy(this->data(), (dev_value_t*)(m_dp), this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateDevice()
{
    CUDA_ERROR_CHECK(cudaMemcpy(this->cuda_deviceData(), this->data(), this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyHostToDevice));
}

/*!
 * Gets a pointer to the device data storage.
 *
 * \result A pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData()
{
    return (dev_value_t*)(m_dp);
}

/*!
 * Gets a constant pointer to the device data storage.
 *
 * \result A constant pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
const dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData() const
{
    return (dev_value_t*)(m_dp);
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_fillDevice(const dev_value_t &value)
{
    if (value == 0) {
        CUDA_ERROR_CHECK(cudaMemset((dev_value_t*)(m_dp), value, this->cuda_deviceDataSize() * sizeof(dev_value_t)));
    } else {
        const int BLOCK_SIZE = 512;
        const int N_BLOCKS   = 8;
        containers::dev_setValue<<<BLOCK_SIZE, N_BLOCKS>>>(this->cuda_deviceDataSize(), value, (dev_value_t*)(m_dp));
    }
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValuePiercedStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return this->cuda_deviceDataSize(this->rawSize());
}

template<typename value_t, typename dev_value_t>
std::size_t ValuePiercedStorage<value_t, dev_value_t>::cuda_deviceDataSize(std::size_t count) const
{
    return (count * this->getFieldCount() * (static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t)));
}

/*!
 * Update host data using device data.
 *
 * \param count is the number of host elements that will be updated
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename value_t, typename dev_value_t>
void ValueStorage<value_t, dev_value_t>::cuda_updateHost(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->data() + hostOffset, this->cuda_deviceData() + deviceOffset, deviceCountBytes, cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 *
 * \param count is the number of host elements that will be used as source for
 * updating device data
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateDevice(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->cuda_deviceData() + deviceOffset, this->data() + hostOffset, deviceCountBytes, cudaMemcpyHostToDevice));
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return this->cuda_deviceDataSize(this->size());
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage in order for it to contain the specified number of host elements.
 *
 * \param count is the number of host elements the device storage should
 * contain
 * \result The size, expressed in number of device elements, of the device
 * data storage in order for it to contain the specified number of host
 * elements.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize(std::size_t count) const
{
    return (count * static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t));
}

/*!
 * Allocate cuda memory.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_allocateDevice()
{
    std::size_t deviceBytes = m_storages.size() * sizeof(dev_value_type);

    CUDA_ERROR_CHECK(cudaMalloc((void **) &m_deviceDataCollection, deviceBytes));
#if ENABLE_OPENACC
    acc_map_data(m_dataCollection.data(), m_deviceDataCollection, deviceBytes);
#endif

    std::size_t nStorages = m_storages.size();
    for (std::size_t k = 0; k < nStorages; ++k) {
        storage_t &storage = m_storages[k];
        storage.cuda_allocateDevice();

        dev_value_type *storageDEviceData = storage.cuda_deviceData();
        CUDA_ERROR_CHECK(cudaMemcpy(m_deviceDataCollection + k, &storageDEviceData, sizeof(dev_value_type *), cudaMemcpyHostToDevice));
    }
}

/*!
 * Free cuda memory.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_freeDevice()
{
    for (auto &storage : m_storages) {
        storage.cuda_freeDevice();
    }

#if ENABLE_OPENACC
    acc_unmap_data(m_dataCollection.data());
#endif
    CUDA_ERROR_CHECK(cudaFree(m_deviceDataCollection));
}

/*!
 * Resize memory
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_resize(size_t new_sz)
{
    std::size_t nStorages = m_storages.size();
    for (std::size_t k = 0; k < nStorages; ++k) {
        storage_t &storage = m_storages[k];
        storage.cuda_resize(new_sz);

        dev_value_type *storageDEviceData = storage.cuda_deviceData();
        CUDA_ERROR_CHECK(cudaMemcpy(m_deviceDataCollection + k, &storageDEviceData, sizeof(dev_value_type *), cudaMemcpyHostToDevice));
    }
}

/*!
 * Update host data using device data.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_updateHost()
{
    for (auto &storage : m_storages) {
        storage.cuda_updateHost();
    }
}

/*!
 * Update device data using host data.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_updateDevice()
{
    for (auto &storage : m_storages) {
        storage.cuda_updateDevice();
    }
}

/*!
 * Gets a pointer to the device data collection.
 *
 * \result A pointer to the device data collection.
 */
template<typename storage_t>
BaseStorageCollection<storage_t>::dev_value_type ** BaseStorageCollection<storage_t>::cuda_deviceCollectionData()
{
    return m_deviceDataCollection;
}

/*!
 * Gets a constant pointer to the device data collection.
 *
 * \result A constant pointer to the device data collection.
 */
template<typename storage_t>
const BaseStorageCollection<storage_t>::dev_value_type * const * BaseStorageCollection<storage_t>::cuda_deviceCollectionData() const
{
    return m_deviceDataCollection;
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_fillDevice(const dev_value_type &value)
{
    for (auto &storage : m_storages) {
        storage.cuda_fillDevice(value);
    }
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceCollectionDataCursor<value_t>::DeviceCollectionDataCursor()
    : DeviceCollectionDataCursor(nullptr, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ DeviceCollectionDataCursor<value_t>::DeviceCollectionDataCursor(value_t **collectionData, std::size_t offset)
    : m_collectionData(collectionData), m_offset(offset)
{
}

/*!
 * Set the cursor.
 *
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataCursor<value_t>::set(std::size_t offset)
{
    m_offset = offset;
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataCursor<value_t>::set(value_t **collectionData, std::size_t offset)
{
    set(offset);

    m_collectionData = collectionData;
}

/*!
 * Return a reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t & DeviceCollectionDataCursor<value_t>::operator[](int index)
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceCollectionDataCursor<value_t>::operator[](int index) const
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t * DeviceCollectionDataCursor<value_t>::data(int index)
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Return a constant pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceCollectionDataCursor<value_t>::data(int index) const
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceCollectionDataConstCursor<value_t>::DeviceCollectionDataConstCursor()
    : DeviceCollectionDataConstCursor(nullptr, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ DeviceCollectionDataConstCursor<value_t>::DeviceCollectionDataConstCursor(const value_t * const *collectionData, std::size_t offset)
    : m_collectionData(collectionData), m_offset(offset)
{
}

/*!
 * Set the cursor.
 *
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataConstCursor<value_t>::set(std::size_t offset)
{
    m_offset = offset;
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataConstCursor<value_t>::set(const value_t * const *collectionData, std::size_t offset)
{
    set(offset);

    m_collectionData = collectionData;
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceCollectionDataConstCursor<value_t>::operator[](int index) const
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceCollectionDataConstCursor<value_t>::data(int index) const
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceStridedDataCursor<value_t>::DeviceStridedDataCursor()
    : DeviceStridedDataCursor(nullptr, 0, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ DeviceStridedDataCursor<value_t>::DeviceStridedDataCursor(value_t *collectionData, std::size_t offset, int stride)
    : m_data(collectionData + stride * offset)
{
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ void DeviceStridedDataCursor<value_t>::set(value_t *collectionData, std::size_t offset, int stride)
{
    m_data = collectionData + stride * offset;
}

/*!
 * Return a reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t & DeviceStridedDataCursor<value_t>::operator[](int index)
{
    return *(m_data + index);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceStridedDataCursor<value_t>::operator[](int index) const
{
    return *(m_data + index);
}

/*!
 * Return a pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t * DeviceStridedDataCursor<value_t>::data(int index)
{
    return (m_data + index);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceStridedDataCursor<value_t>::data(int index) const
{
    return (m_data + index);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceStridedDataConstCursor<value_t>::DeviceStridedDataConstCursor()
    : DeviceStridedDataConstCursor(nullptr, 0, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ DeviceStridedDataConstCursor<value_t>::DeviceStridedDataConstCursor(const value_t *collectionData, std::size_t offset, int stride)
    : m_data(collectionData + stride * offset)
{
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ void DeviceStridedDataConstCursor<value_t>::set(const value_t *collectionData, std::size_t offset, int stride)
{
    m_data = collectionData + stride * offset;
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceStridedDataConstCursor<value_t>::operator[](int index) const
{
    return *(m_data + index);
}

/*!
 * Return a constant pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceStridedDataConstCursor<value_t>::data(int index) const
{
    return (m_data + index);
}

/*!
 * Constructor
 */
template<typename value_t, int STRIDE>
__device__ DeviceProxyArray<value_t, STRIDE>::DeviceProxyArray()
    : DeviceProxyArray(nullptr, 0)
{
}

/*!
 * Constructor
 *
 * \param data is a pointer to the shared data
 * \param offset is the offset to be used when accessing the data
 */
template<typename value_t, int STRIDE>
__device__ DeviceProxyArray<value_t, STRIDE>::DeviceProxyArray(value_t *data, std::size_t offset)
    : m_data(data + offset)
{
}

/*!
 * Set the array.
 *
 * \param data is a pointer to the shared data
 * \param offset is the offset to be used when accessing the data
 */
template<typename value_t, int STRIDE>
__device__ void DeviceProxyArray<value_t, STRIDE>::set(value_t *data, std::size_t offset)
{
    m_data = data + offset;
}

/*!
 * Return a reference to the specified item.
 *
 * \param index is the index of the item
 * \result A reference to the specified item.
 */
template<typename value_t, int STRIDE>
__device__ value_t & DeviceProxyArray<value_t, STRIDE>::operator[](int index)
{
    return m_data[STRIDE * index];
}

/*!
 * Return a constant reference to the specified item.
 *
 * \param index is the index of the item
 * \result A constant reference to the specified item.
 */
template<typename value_t, int STRIDE>
__device__ const value_t & DeviceProxyArray<value_t, STRIDE>::operator[](int index) const
{
    return m_data[STRIDE * index];
}

/*!
 * Evaluates the size of the shared storage, expressed in number of elements,
 * needed to store the requested number of elements.
 *
 * \param size is the number of items elements will be stored in the array
 * \result Returns the size of the shared storage expressed in number of
 * elements.
 */
template<typename value_t, int BLOCK_SIZE>
__device__ int DeviceSharedArray<value_t, BLOCK_SIZE>::evaluateSharedSize(int size)
{
    return (BLOCK_SIZE * size);
}

/*!
 * Constructor
 */
template<typename value_t, int BLOCK_SIZE>
__device__ DeviceSharedArray<value_t, BLOCK_SIZE>::DeviceSharedArray()
    : DeviceSharedArray(nullptr)
{
}

/*!
 * Constructor
 *
 * \param data is a pointer to the shared array
 */
template<typename value_t, int BLOCK_SIZE>
__device__ DeviceSharedArray<value_t, BLOCK_SIZE>::DeviceSharedArray(value_t *data)
    : DeviceProxyArray<value_t, BLOCK_SIZE>(data, threadIdx.x)
{
}

/*!
 * Constructor
 *
 * \param data is a pointer to the shared array
 * \param threadId is the id of the thread whose data need to be accessed
 */
template<typename value_t, int BLOCK_SIZE>
__device__ DeviceSharedArray<value_t, BLOCK_SIZE>::DeviceSharedArray(value_t *data, int threadId)
    : DeviceProxyArray<value_t, BLOCK_SIZE>(data, threadId)
{
}

/*!
 * Set the array.
 *
 * \param data is a pointer to the shared data
 */
template<typename value_t, int BLOCK_SIZE>
__device__ void DeviceSharedArray<value_t, BLOCK_SIZE>::set(value_t *data)
{
    set(data, threadIdx.x);
}

/*!
 * Set the array.
 *
 * \param data is a pointer to the shared data
 * \param threadId is the id of the thread whose data need to be accessed
 */
template<typename value_t, int BLOCK_SIZE>
__device__ void DeviceSharedArray<value_t, BLOCK_SIZE>::set(value_t *data, int threadId)
{
    DeviceProxyArray<value_t, BLOCK_SIZE>::set(data, threadId);
}

#endif
