/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_CONTAINERS_TCU__
#define __MINIMMERFLOW_CONTAINERS_TCU__

namespace containers {

/*!
 * Set all storage elements to the specified value.
 *
 * \param count are the number of elements that will be set
 * \param data is a pointer to the first element
 * \param is the value that will be set
 */
template<typename dev_value_t>
__global__ void dev_setValue(std::size_t nElements, dev_value_t value, dev_value_t *data)
{
    unsigned int i = (blockIdx.x * blockDim.x) + threadIdx.x;
    for(; i < nElements; i += gridDim.x*blockDim.x) {
        data[i] = value;
    }
}

}

/*!
 * Allocate cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_allocateDevice()
{
    std::size_t deviceBytes = this->cuda_deviceDataSize() * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMalloc((void **) &m_deviceData, deviceBytes));
#if ENABLE_OPENACC
    acc_map_data(this->data(), m_deviceData, deviceBytes);
#endif
}

/*!
 * Free cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_freeDevice()
{
#if ENABLE_OPENACC
    acc_unmap_data(this->data());
#endif
    CUDA_ERROR_CHECK(cudaFree(m_deviceData));
}

/*!
 * Update host data using device data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateHost()
{
    CUDA_ERROR_CHECK(cudaMemcpy(this->data(), m_deviceData, this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateDevice()
{
    CUDA_ERROR_CHECK(cudaMemcpy(m_deviceData, this->data(), this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyHostToDevice));
}

/*!
 * Gets a pointer to the device data storage.
 *
 * \result A pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData()
{
    return m_deviceData;
}

/*!
 * Gets a constant pointer to the device data storage.
 *
 * \result A constant pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
const dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData() const
{
    return m_deviceData;
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_fillDevice(const dev_value_t &value)
{
    if (value == 0) {
        CUDA_ERROR_CHECK(cudaMemset(this->m_deviceData, value, this->cuda_deviceDataSize() * sizeof(dev_value_t)));
    } else {
        const int BLOCK_SIZE = 512;
        const int N_BLOCKS   = 8;
        containers::dev_setValue<<<BLOCK_SIZE, N_BLOCKS>>>(this->cuda_deviceDataSize(), value, this->m_deviceData);
    }
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValuePiercedStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return (this->rawSize() * this->getFieldCount() * static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t));
}

/*!
 * Update host data using device data.
 *
 * \param count is the number of host elements that will be updated
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename value_t, typename dev_value_t>
void ValueStorage<value_t, dev_value_t>::cuda_updateHost(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->data() + hostOffset, this->cuda_deviceData() + deviceOffset, deviceCountBytes, cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 *
 * \param count is the number of host elements that will be used as source for
 * updating device data
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename value_t, typename dev_value_t>
void ValueStorage<value_t, dev_value_t>::cuda_updateDevice(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->cuda_deviceData() + deviceOffset, this->data() + hostOffset, deviceCountBytes, cudaMemcpyHostToDevice));
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return this->cuda_deviceDataSize(this->size());
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage in order for it to contain the specified number of host elements.
 *
 * \param count is the number of host elements the device storage should
 * contain
 * \result The size, expressed in number of device elements, of the device
 * data storage in order for it to contain the specified number of host
 * elements.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize(std::size_t count) const
{
    return (count * static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t));
}

/*!
 * Allocate cuda memory.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_allocateDevice()
{
    CUDA_ERROR_CHECK(cudaMalloc((void **) &m_deviceDataCollection, m_storages.size() * sizeof(dev_value_type)));

    std::size_t nStorages = m_storages.size();
    for (std::size_t k = 0; k < nStorages; ++k) {
        storage_t &storage = m_storages[k];
        storage.cuda_allocateDevice();

        dev_value_type *storageDEviceData = storage.cuda_deviceData();
        CUDA_ERROR_CHECK(cudaMemcpy(m_deviceDataCollection + k, &storageDEviceData, sizeof(dev_value_type *), cudaMemcpyHostToDevice));
    }
}

/*!
 * Free cuda memory.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_freeDevice()
{
    for (auto &storage : m_storages) {
        storage.cuda_freeDevice();
    }

    CUDA_ERROR_CHECK(cudaFree(m_deviceDataCollection));
}

/*!
 * Update host data using device data.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_updateHost()
{
    for (auto &storage : m_storages) {
        storage.cuda_updateHost();
    }
}

/*!
 * Update device data using host data.
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_updateDevice()
{
    for (auto &storage : m_storages) {
        storage.cuda_updateDevice();
    }
}

/*!
 * Gets a pointer to the device data collection.
 *
 * \result A pointer to the device data collection.
 */
template<typename storage_t>
BaseStorageCollection<storage_t>::dev_value_type ** BaseStorageCollection<storage_t>::cuda_deviceCollectionData()
{
    return m_deviceDataCollection;
}

/*!
 * Gets a constant pointer to the device data collection.
 *
 * \result A constant pointer to the device data collection.
 */
template<typename storage_t>
const BaseStorageCollection<storage_t>::dev_value_type * const * BaseStorageCollection<storage_t>::cuda_deviceCollectionData() const
{
    return m_deviceDataCollection;
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename storage_t>
void BaseStorageCollection<storage_t>::cuda_fillDevice(const dev_value_type &value)
{
    for (auto &storage : m_storages) {
        storage.cuda_fillDevice(value);
    }
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceCollectionDataCursor<value_t>::DeviceCollectionDataCursor()
    : DeviceCollectionDataCursor(nullptr, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ DeviceCollectionDataCursor<value_t>::DeviceCollectionDataCursor(value_t **collectionData, std::size_t offset)
    : m_collectionData(collectionData), m_offset(offset)
{
}

/*!
 * Set the cursor.
 *
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataCursor<value_t>::set(std::size_t offset)
{
    m_offset = offset;
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataCursor<value_t>::set(value_t **collectionData, std::size_t offset)
{
    set(offset);

    m_collectionData = collectionData;
}

/*!
 * Return a reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t & DeviceCollectionDataCursor<value_t>::operator[](int index)
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceCollectionDataCursor<value_t>::operator[](int index) const
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t * DeviceCollectionDataCursor<value_t>::data(int index)
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Return a constant pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceCollectionDataCursor<value_t>::data(int index) const
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceCollectionDataConstCursor<value_t>::DeviceCollectionDataConstCursor()
    : DeviceCollectionDataConstCursor(nullptr, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ DeviceCollectionDataConstCursor<value_t>::DeviceCollectionDataConstCursor(const value_t * const *collectionData, std::size_t offset)
    : m_collectionData(collectionData), m_offset(offset)
{
}

/*!
 * Set the cursor.
 *
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataConstCursor<value_t>::set(std::size_t offset)
{
    m_offset = offset;
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 */
template<typename value_t>
__device__ void DeviceCollectionDataConstCursor<value_t>::set(const value_t * const *collectionData, std::size_t offset)
{
    set(offset);

    m_collectionData = collectionData;
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceCollectionDataConstCursor<value_t>::operator[](int index) const
{
    return *(m_collectionData[index] + m_offset);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceCollectionDataConstCursor<value_t>::data(int index) const
{
    return (m_collectionData[index] + m_offset);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceStridedDataCursor<value_t>::DeviceStridedDataCursor()
    : DeviceStridedDataCursor(nullptr, 0, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ DeviceStridedDataCursor<value_t>::DeviceStridedDataCursor(value_t *collectionData, std::size_t offset, int stride)
    : m_data(collectionData + stride * offset)
{
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ void DeviceStridedDataCursor<value_t>::set(value_t *collectionData, std::size_t offset, int stride)
{
    m_data = collectionData + stride * offset;
}

/*!
 * Return a reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t & DeviceStridedDataCursor<value_t>::operator[](int index)
{
    return *(m_data + index);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceStridedDataCursor<value_t>::operator[](int index) const
{
    return *(m_data + index);
}

/*!
 * Return a pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ value_t * DeviceStridedDataCursor<value_t>::data(int index)
{
    return (m_data + index);
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceStridedDataCursor<value_t>::data(int index) const
{
    return (m_data + index);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceStridedDataConstCursor<value_t>::DeviceStridedDataConstCursor()
    : DeviceStridedDataConstCursor(nullptr, 0, 0)
{
}

/*!
 * Constructor
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ DeviceStridedDataConstCursor<value_t>::DeviceStridedDataConstCursor(const value_t *collectionData, std::size_t offset, int stride)
    : m_data(collectionData + stride * offset)
{
}

/*!
 * Set the cursor.
 *
 * \param collectionData is a pointer the data of the collection
 * \param offset is the offset that shouldd be used to access the data
 * \param stride is the stride that should be used to accesst the data
 */
template<typename value_t>
__device__ void DeviceStridedDataConstCursor<value_t>::set(const value_t *collectionData, std::size_t offset, int stride)
{
    m_data = collectionData + stride * offset;
}

/*!
 * Return a constant reference to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant reference to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t & DeviceStridedDataConstCursor<value_t>::operator[](int index) const
{
    return *(m_data + index);
}

/*!
 * Return a constant pointer to the data pointed by the cursor.
 *
 * \param index is the index of the storage
 * \result A constant pointer to the data pointed by the cursor.
 */
template<typename value_t>
__device__ const value_t * DeviceStridedDataConstCursor<value_t>::data(int index) const
{
    return (m_data + index);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceProxyArray<value_t>::DeviceProxyArray()
    : DeviceProxyArray(nullptr, 0, 0)
{
}

/*!
 * Constructor
 *
 * \param data is a pointer to the shared data
 * \param offset is the offset to be used when accessing the data
 * \param stride is the stride to be used when accessing the data
 */
template<typename value_t>
__device__ DeviceProxyArray<value_t>::DeviceProxyArray(value_t *data, std::size_t offset, int stride)
    : m_data(data + offset), m_stride(stride)
{
}

/*!
 * Set the array.
 *
 * \param data is a pointer to the shared data
 * \param offset is the offset to be used when accessing the data
 * \param stride is the stride to be used when accessing the data
 */
template<typename value_t>
__device__ void DeviceProxyArray<value_t>::set(value_t *data, std::size_t offset, int stride)
{
    m_data   = data + offset;
    m_stride = stride;
}

/*!
 * Return a reference to the specified item.
 *
 * \param index is the index of the item
 * \result A reference to the specified item.
 */
template<typename value_t>
__device__ value_t & DeviceProxyArray<value_t>::operator[](int index)
{
    return m_data[m_stride * index];
}

/*!
 * Return a constant reference to the specified item.
 *
 * \param index is the index of the item
 * \result A constant reference to the specified item.
 */
template<typename value_t>
__device__ const value_t & DeviceProxyArray<value_t>::operator[](int index) const
{
    return m_data[m_stride * index];
}

/*!
 * Evaluates the size of the shared storage, expressed in number of elements,
 * needed to store the requested number of elements.
 *
 * \param size is the number of items elements will be stored in the array
 * \result Returns the size of the shared storage expressed in number of
 * elements.
 */
template<typename value_t>
__device__ int DeviceSharedArray<value_t>::evaluateSharedSize(int size)
{
    int nThreads = blockDim.x * blockDim.y * blockDim.z;

    return (nThreads * size);
}

/*!
 * Constructor
 */
template<typename value_t>
__device__ DeviceSharedArray<value_t>::DeviceSharedArray()
    : DeviceSharedArray(nullptr)
{
}

/*!
 * Constructor
 *
 * \param data is a pointer to the shared array
 */
template<typename value_t>
__device__ DeviceSharedArray<value_t>::DeviceSharedArray(value_t *data)
    : DeviceProxyArray<value_t>(data, threadIdx.x, blockDim.x * blockDim.y * blockDim.z)
{
}

/*!
 * Set the array.
 *
 * \param data is a pointer to the shared data
 */
template<typename value_t>
__device__ void DeviceSharedArray<value_t>::set(value_t *data)
{
    DeviceProxyArray<value_t>::set(data, threadIdx.x, blockDim.x * blockDim.y * blockDim.z);
}

#endif
