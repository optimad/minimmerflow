/*---------------------------------------------------------------------------*\
 *
 *  minimmerflow
 *
 *  Copyright (C) 2015-2021 OPTIMAD engineering Srl
 *
 *  -------------------------------------------------------------------------
 *  License
 *  This file is part of minimmerflow.
 *
 *  minimmerflow is free software: you can redistribute it and/or modify it
 *  under the terms of the GNU Lesser General Public License v3 (LGPL)
 *  as published by the Free Software Foundation.
 *
 *  minimmerflow is distributed in the hope that it will be useful, but WITHOUT
 *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 *  FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
 *  License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License
 *  along with minimmerflow. If not, see <http://www.gnu.org/licenses/>.
 *
\*---------------------------------------------------------------------------*/

#ifndef __MINIMMERFLOW_CONTAINERS_TCU__
#define __MINIMMERFLOW_CONTAINERS_TCU__

namespace containers {

/*!
 * Set all storage elements to the specified value.
 *
 * \param count are the number of elements that will be set
 * \param data is a pointer to the first element
 * \param is the value that will be set
 */
template<typename dev_value_t>
__global__ void dev_setValue(std::size_t nElements, dev_value_t value, dev_value_t* __restrict__ data)
{
    unsigned int i = (blockIdx.x * blockDim.x) + threadIdx.x;
    for(; i < nElements; i += gridDim.x*blockDim.x) {
        data[i] = value;
    }
}

}

/*!
 * Allocate cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_allocateDevice()
{
    std::size_t deviceBytes = this->cuda_deviceDataSize() * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMalloc((void **) &m_deviceData, deviceBytes));
#if ENABLE_OPENACC
    acc_map_data(this->data(), m_deviceData, deviceBytes);
#endif
}

/*!
 * Free cuda memory.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_freeDevice()
{
#if ENABLE_OPENACC
    acc_unmap_data(this->data());
#endif
    CUDA_ERROR_CHECK(cudaFree(m_deviceData));
}

/*!
 * Update host data using device data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateHost()
{
    CUDA_ERROR_CHECK(cudaMemcpy(this->data(), m_deviceData, this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_updateDevice()
{
    CUDA_ERROR_CHECK(cudaMemcpy(m_deviceData, this->data(), this->cuda_deviceDataSize() * sizeof(dev_value_t), cudaMemcpyHostToDevice));
}

/*!
 * Gets a pointer to the device data storage.
 *
 * \result A pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData()
{
    return m_deviceData;
}

/*!
 * Gets a constant pointer to the device data storage.
 *
 * \result A constant pointer to the device data storage.
 */
template<typename container_t, typename value_t, typename dev_value_t>
const dev_value_t * ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_deviceData() const
{
    return m_deviceData;
}

/*!
 * Fill the container with the specified value.
 *
 * \param value is the value that will be used to fille the container
 */
template<typename container_t, typename value_t, typename dev_value_t>
void ValueBaseStorage<container_t, value_t, dev_value_t>::cuda_fillDevice(const dev_value_t &value)
{
    if (value == 0) {
        CUDA_ERROR_CHECK(cudaMemset(this->m_deviceData, value, this->cuda_deviceDataSize() * sizeof(dev_value_t)));
    } else {
        const int BLOCK_SIZE = 512;
        const int N_BLOCKS   = 8;
        containers::dev_setValue<<<BLOCK_SIZE, N_BLOCKS>>>(this->cuda_deviceDataSize(), value, this->m_deviceData);
    }
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValuePiercedStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return (this->rawSize() * this->getFieldCount() * static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t));
}

/*!
 * Update host data using device data.
 *
 * \param count is the number of host elements that will be updated
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename value_t, typename dev_value_t>
void ValueStorage<value_t, dev_value_t>::cuda_updateHost(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->data() + hostOffset, this->cuda_deviceData() + deviceOffset, deviceCountBytes, cudaMemcpyDeviceToHost));
}

/*!
 * Update device data using host data.
 *
 * \param count is the number of host elements that will be used as source for
 * updating device data
 * \param offset is the offset, expressed in host elements, that will be used when
 * updating the data
 */
template<typename value_t, typename dev_value_t>
void ValueStorage<value_t, dev_value_t>::cuda_updateDevice(std::size_t count, std::size_t offset)
{
    std::size_t hostOffset = offset * sizeof(value_t);

    std::size_t deviceOffset     = this->cuda_deviceDataSize(offset);
    std::size_t deviceCountBytes = this->cuda_deviceDataSize(count) * sizeof(dev_value_t);

    CUDA_ERROR_CHECK(cudaMemcpy(this->cuda_deviceData() + deviceOffset, this->data() + hostOffset, deviceCountBytes, cudaMemcpyHostToDevice));
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage.
 *
 * \result The size, expressed in number of device elements, of the device
 * data storage.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize() const
{
    return this->cuda_deviceDataSize(this->size());
}

/*!
 * Get the size, expressed in number of device elements, of the device data
 * storage in order for it to contain the specified number of host elements.
 *
 * \param count is the number of host elements the device storage should
 * contain
 * \result The size, expressed in number of device elements, of the device
 * data storage in order for it to contain the specified number of host
 * elements.
 */
template<typename value_t, typename dev_value_t>
std::size_t ValueStorage<value_t, dev_value_t>::cuda_deviceDataSize(std::size_t count) const
{
    return (count * static_cast<double>(sizeof(value_t)) / sizeof(dev_value_t));
}

#endif
